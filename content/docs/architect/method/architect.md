---
Categories : ["服务治理"]
title: "服务治理"
date: 2018-10-10T16:49:27+08:00
---

# 原则
    高并发
    高可用
    高可靠
        SLA(service level agreement)制定(吞吐量、响应时间、可用性、降级方案)
        容量规划(流量、容量)
        监控报警(机器负载、响应时间、可用率)
            tracing
        应急预案(容灾、降级、限流、隔离、切流量、可回滚)
    成本
    经济学原理
        比较优势
            服务器类型
        分工协作
            组合
        货币解耦
            MQ
        规模效益
            集群
# 高可用
## 负载均衡
    流量切换     # 某服务器挂了
        DNS切换
        httpDNS         # app配置，绕过运营商localDNS
        lvs/haproxy     # 切换故障的nginx
        nginx           # 切换故障应用
## 限流
    思路
        恶意请求流量只访问cache
        穿透到应用的流量用nginx limit
        恶意ip nginx deny
## 降级
    开关集中化管理, 推送开关配置
    开关前置      # nginx层做开关
    可降级读服务   # 只读本地缓存、只读分布式缓存、只读默认数据
    业务降级      # 部分业务异步，处理高优先级，分配流量保障系统可用
## 隔离
    线程隔离
    进程隔离
    集群隔离
    机房隔离
    读写隔离
    动静隔离
    爬虫隔离
    热点隔离
    资源隔离
## 回滚
    事务
    代码库
    部署版本
    数据版本
    静态资源版本
## 超时与重试
## 压测与预案
    线下、线上
# 高并发
## 缓存
    客户端
        浏览器缓存   # Pragma, Expires, Cache-control
        ajax
        app缓存     # 大促时更新静态资源, 地图
    客户端网络      # 代理服务器缓存
    广域网
        代理服务器(如CDN)
            推送 或 拉取(回源)
        镜像服务器
        P2P
    源站
        接入层缓存   # 如页面缓存，用redis
            url重写
            一致性哈希
            proxy_cache         # 内存/SSD缓存内容
            proxy_cache_lock    # 一段时间的回源合并成一个
            shared_dict         # lua, 重启缓存不丢失
        应用层缓存           # 如搜索，建议物品等
            堆内缓存
            堆外缓存        # local redis cache
        分布式缓存(接入层后)
            redis集群     # 异步化写入, lua-resty-lock(非阻塞锁)
        对象缓存    # db和应用间的查询结果集
        静态化, 伪静态化
        服务器操作系统缓存
## 连接池线程池
## 异步化
## 队列
    作用
        服务解耦
        异步处理
        流量削峰/缓冲     # 如促销期
    问题
        丢失/失败     # 持久化，日志，报警, 数据校对修正(worker扫库)
        重复          # 业务上防重
    例子
        redis扣库存->记录日志->同步worker->DB
    消息总线可扩展     # x扩展不行，y扩展用专用总线(降低了灵活性), z扩展根据客户
    减少拥挤          # 消息划分价值
## 扩容
    无状态     # 应用无状态，配置有状态
        尽可能浏览器端维护会话
        分布式缓存放状态
    拆分  # 加法组合，乘法功能
          # 项目死于1到10，或10到100，因为解耦不够，无法重构
        业务拆分
        功能细分
        读写      # 读缓存，写分库分表，聚合数据
        AOP      # 如CDN
        模块      # 代码特征，如基础模块分库分表，数据库连接池
    数据异构
        例子
            聚合数据表(一般KV存储)   # 数据闭环(不依赖其它服务)
            历史归档
        并发化
    选择工具
        数据库     # rdb, nosql, hadoop
        防火墙     # 墙需要的东西
        日志       # 采集分析
        用同品牌设备
        慎用第三方
    容错
        隔离               # 不同步调用，限制异步调用(数量和超时)，能迅速发现故障
        不单点             # 一切都出故障
        不系统串联
        功能支持启用禁用    # 实现wire on/wire off框架

# 服务方法
## 成本分析
    # autonomy.design
    表现
        一个需求拉很多人，代码写进来就删不掉了
        通用功能要么多种实现，要么参数过多
        线上问题难定位，本地做不了有意义的测试，反馈周期特别长
    本质
        减少沟通
            autonomy(自治): 减少沟通，功能可以删掉
                问题: 产品从整体效果出发，开发从实现出发
                依赖倒置
                    UI插槽, 服务集成
                    实现(服务)
                        编译时: 模板、函数替换
                        运行时: 组合对象、组合函数
                    实现(UI)
                        编译时: 页面模板替换, 显式组合与隐式组合
                        运行时: Vue插槽
            feedback(反馈): 故障定位，测试反馈，发版反馈，用户反馈无响应
                控制边界
                    进程
                        跨进程调用监控: 基础设施完善
                        OS强制配额、安全性: 基础设施好
                        内存隔离
                    函数
                        caller/callee索引: 同步调用栈、异步调用链、组件树
                        问题: 日志多，负责模糊
                    插件
                控制变更
                    多进程
                        多进程部署
                    多租户
                    多变种
                        配置中心下发开关
            consistency(一致性): 工具复用
                用户可见的一致性: UI/UE设计，前端落地
                autonomy: 上层业务推动
                    问题: 依赖修改要慎重
                feedback: QA, KPI
    拆分
        组合关系
            加法
            乘法
            一致性复用
## 扩展方式
    服务化发展
        进程内服务
        单机远程服务
        集群手动注册服务(nginx负载多实例)
        自动注册和发现服务(zookeeper)
        服务分组/隔离/路由
        服务治理(限流/黑白名单)
    AKF扩展立方
        x轴 横向复制                 # 复制服务或db, 瓶颈：内存缓存、特有数据
        y轴 面向功能、服务、资源拆分   # 微服务
            动词拆分                 # 登录、搜索、推荐等
            名词拆分                 # 目录、库存、账户等
        z轴 拆相近东西               # 数据分片(大小客户、地区、新旧等)
    横向扩展    # 复制服务或数据分散负载，纵向扩展是升级设备
        使用经济型系统
        扩展数据中心      # 三实时站点备份: a(0.5b, 0.5c), b(0.5a, 0.5c), c(0.5a,0.5b), 尽量分散
        使用云
## 微服务
    单体应用问题
        复杂: 模块多, 边界模糊, 依赖关系不清晰, 代码质量不统一
        技术债务: 不坏不修
        部署频率低: 迭代要部署整个应用，部署时间长，风险高。修复问题慢, 易出错
        可靠性差: 某bug导致整个应用崩溃
        扩展性差
        阻碍技术更新
    特征
        服务组件化
        按业务组织团队
        负责的态度, 不再是交付给维护者
        粗粒度通信, http(二进制协议)或消息总线
        去中心化治理
        去中心化管理数据
        基础设施自动化
        容错设计
        演进式设计
    原则
        单一职责
        自洽
        轻量级通信
        服务粒度: 边界(DDD中的界限上下文)
    持续发布
        工具链，自动化
        契约
        架构守护
        灰度替换
    *aaS
        SaaS(software as a service)
        PaaS(platform as a service)
        aPaaS(application PaaS)         # 简单配置产生任意需求的application
        saPaaS(specific aPaaS)          # 领域定制的aPaaS
        GaPaaS(generator of aPaaS)      # 脚手架，产生定制的aPaaS
## 云原生
    介绍
        cloud navtive, Pivotal 2013年提出
    12-Factor
        1 基准代码(code base)
            一份代码，多份部署
        2 依赖(dependences)
            显式声明依赖
        3 配置(config)
            配置存储于环境变量中
            环境变量粒度足够小，相对独立
        4 后端服务(backing services)
            后端服务作为附加资源, 与第三方服务不区别对待
        5 分离构建、发布、运行(build, release, run)
            构建: 代码转化到可执行包
            发布: 可执行包结合配置
            运行: 选定发布版本，按计划启动
        6 进程(process)
            多个无状态进程运行
        7 端口(port binding)
            网络服务通过端口绑定提供服务
            完全自我加载不依赖网络服务器
        8 并发(concurrency)
            进程作为一等公民
            通过进程模型扩展并发
        9 易处理(disposability)
            进程快速启动、优雅终止可最大化健壮性
            追求最小启动时间, 收到SIGTERM优雅终止，突然死亡时保持健壮
        10 环境等价(dev/prod parity)
            开发环境等价线上环境
        11 日志(logs)
            日志作为事件流
            应用本身使用stdout事件流，不考虑存储输出流，不管理日志
        12 管理进程(admin processes)
            管理进程不常驻, 一次性运行
            使用同样环境、代码版本、配置、依赖隔离, 避免同步问题
            提供REPL shell使一次性脚本变简单
### Service Mesh
    处于 TCP/IP 之上的抽象层
## Serverless
    只写业务代码，不关心服务器运行状态
    BaaS
        # Backend as a Service
    FaaS
        # Functions as a Service
