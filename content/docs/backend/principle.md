# 事件
    # 非阻塞
    实现
        回调
        队列存事件, 单进程检测事件是否回调
    工具
        epoll(select, poll)
        libev(libevent)
# 并发并行
    并发
        为什么: 多任务能力，非阻塞
        类比: 任务队列
    并行
        为什么: 提高执行效率
        类比: 多核处理器
        并行代码：编译代码顺序不确定，或执行顺序不确定
        面临竞争问题
        业务并行
            解耦业务
            业务满足幺半群性质
                封闭性     # 业务运算结果是业务
                结合律     # 业务a、b的结果后与c执行，等同b、c的结果与a执行
                单位元     # 单位业务a与其它业务b执行，得b
    系统应用
        并发能力
        吞吐量(并行)
            I/O多路复用(epoll)
            cpu"多路复用"(进程、线程)
            cpu机制(多发射、流水线、超标量、超线程)
        进程线程应用
            cpu对任务的M:N处理
            进程切换处理任务
            线程(通信，并行)
    实现(异步, 并发，并行)
        写法
            回调(监听器), 链式(promise)，同步(async)
        事件处理器
            调度方式: 单线程循环
        协程
            为什么用户实现协程
                POSIX线程模型累赘
                    进程/线程 切换开销大
                    空间资源占用大
                os调度对go模型不合理
                    go gc需要内存处理一致状态(所有线程停止), os调度时，因gc时间不确定，期间大量线程停止工作
                        # go调度器知道什么时候内存处于一致性状态(只需正在核上运行线程)
            本质
                用户态，寄存器+栈, 让出
            调度方式(线程模型)
                N:1     # N个用户空间线程运行在1个内核空间线程
                    上下文切换快
                    无法利用多核
                1:1
                    # POSIX(pthread), java
                    利用多核
                    上下文切换慢，每次调度都在用户态和内核态间切换
                M:N
                    任意内核模型管理任意goroutine
                    调度复杂性大
            go
                M(machine)代表内核线程
                G(goroutine)有自己的栈，程序计数器，调度信息(如正阻塞的channel)
                P(processor)调度上下文, $GOMAXPROCS设置数量
                P中有G队列(runqueue, 队尾添加新G)
                    当前运行一个G, 到调度点时，队列弹出另一个G
                    P周期检查全局G队列防止其中G饿死
                    P运行完，全局G队列拉取G
                    P运行完，全局G队列空，从其它P拉取一半G
                P运行在M, M阻塞时P移到其它M, 阻塞M中保留阻塞的G
                调度器创建足够多M跑P
                    阻塞M中G的syscall返回, M尝试偷一个P
                    没得到P时, 它的G加入全局G队列, M进线池睡眠

    概念
        过度竞争
            过多线程尝试同时使用一个共享资源
        同步  # 直接相互制约
        互斥  # 间接相互制约
            竞态条件(race condition)
        异步
            # 与同步相对。多线程是实现异步的一种手段
        可见性
            线程总可见到最后修改的数据, 脏读是反例
        原子性
            查看和修改同时发生
        乱序执行
            # java 中标记volatile的变量可以不乱序执行, 现多用原子变量
            编译器或JVM的静态优化可以打乱代码执行顺序(java)
            硬件可以通过乱序执行来优化性
        死锁  # 多线程竞争资源而互相等待
            条件
                互斥      # 资源排他
                不剥夺    # 资源不被外力剥夺
                请求和保持条件     # 线程已保持一个资源，请求新资源。请求被阻塞而自己资源保持
                循环等待    # 阻塞线程形成环
            方案
                锁按顺序获得  # a,b,c锁，要得c手中要有a, b
                    # 使用锁的地方比较零散时，遵守此顺序变得不实际
                    # 可以用对象散列值作全局顺序减小死锁机率
                阻塞加时限
                # 外星方法中可能包含另一把锁，要避免在持锁时调用外星方法
## 多线程
    线程池
        作用
            重复利用, 降低资源消耗
            提高响应速度，不等线程创建
            可管理，线程是稀缺资源，统一分配，调优和监控，提高系统稳定性
## 锁
    锁
        公平锁         # FIFO取锁
        非公平锁        # 每次直接占有
        乐观锁         # 假设最好，有冲突时重试
        悲观锁         # 假设最坏，等所有线程释放成功
        互斥锁(mutex)
            # 访问前加锁，访问后解锁
            悲观锁
                读加锁
            乐观锁
                读不加锁，写时判断数据版本是否修改，再重试
        读写锁 rwlock
            状态
                读加锁状态
                    可个线程占用
                    阻塞写线程
                        # 导致写线程抢占不到资源，所以有写线程时，阻塞后进入的读线程
                写加锁状态
                    一次只有一个线程占用
                    阻塞所有线程
                不加锁状态
        自旋锁 spinlock
            互斥锁改，自己进入循环等待状态(忙等)
                # 适合锁持有时间较短
        RCU锁 Read-Copy Update
            读写锁改，一个写线程，读线程无限制
                实现垃圾回收器
                写线程copy副本修改，向垃圾回收器注册callback以执行真正的修改
                垃圾回收器收到信号，所有读线程结束，执行callback
        可重入锁
            # 互斥锁改，允许同一线程多次获得写锁
        管程(monitor)
        临界区(critical section)
        内置锁、显示锁
            # 指java的synchronized与Reentrantlock
    信号量
        进程, 线程间通知状态
## CAS
    # compare and swap，无锁算法(lock free), 非阻塞(non-blocking), 构成基本的乐观锁
    # cpu实现的指令
    3个操作数
        # V的值为A时，原子更新成B，否则无操作。返回V的值
        需要读写的内存位置V
        进行比较的值A
        拟写入的新值B
## 函数式
    介绍
        消除可变状态
    概念
        命令式语言中，求值顺序与源码的语句顺序紧密相关(有可能乱序执行)
        函数式程序并不描述"如何求值以得到结果"，而是描述"结果应当是什么样的"。函数式编程中，如何安排求值顺序相对自由
        引用透明性
            # 任何调用函数的地方，都可以用函数运行结果来替换函数调用，而不会产生副作用
        数据流式编程(dataflow programming)
            # (+ (+ 1 2) (+ 3 4))就是一个数据流，所有函数都可以用时执行
            future模型
## 分离标识与状态
    介绍
        Clojure, 指令式编程和函数式编程混搭

    clojure四种并发模型
        vars (thread-local)
        atoms原子变量
        agent代理
        refs引用 与 ATM软件事务内存
## actor模型
    介绍
        作为actor自己修改自己的数据，对外提供消息，处理对外消息
        共享内存模型和分布式内存模型，适合解决地理分布型问题，强大的容错性
        基于消息传递，侧重通道两端实体
        每个actor有一个mailbox, mailbox中转消息
## csp
    介绍
        通信顺序进程(communicating sequential processes)
        基于消息传递，侧重信息通道
## 数据级并行
    # 不可变数据
## lambda架构
    介绍
        综合MapReduce和流式处理的特点，处理大数据问题的架构
# 状态保持
    cookie
        分域名, 客户端保存服务器定义数据, 请求时发送
    session
        服务器id数据，id下发到客户端
        共享
            # 同时多方案，动态切换 zookeeper切换环境变量与重启
            # java中filter重写request getSession
            webSphere或JBoss可配置session复制或共享
                # 不好扩展和移植
            加密存cookie
            服务
                redis
                memorycache
                gemfire     # 12306
# 认证
    单点登录
        sessionID存cookie, cookie禁用存头域
    token
        类型
            access token
                # 标识唯一用户
                user_id
                issue_time
                    # token发放时间，单位秒
                ttl
                    # 有效时间，uint16,单位分钟
                mask
                    # int128, 按bit分组用户，用于批量封禁或其它功能
            refresh token
                # 用来换access token，与access token同时发放
                # 过期时间更长
        实现
            redis存储
            token不要太长
