---
Categories : ["设计"]
title: "工程"
date: 2018-10-10T17:39:31+08:00
---
# 产品
    愿景
        定义产品的目的和原因，将到达的地点
    ux
        微交互                  # 细节决定成败
## RoadMap
    介绍
        到达愿景的策略路径，提供一系列与产品战略相一致的战术步骤
    为什么
        简单、清晰的通讯文档
            少的多的会议
            健康的团队辩论：交付成果与目标联系起来
            做出每个人都理解的产品决定，不再打击创意
        高维度的概述
        动态演变
    要素
        时间周期
            时间区间，只定时间范围
                big-view(product)
                    全局理解产品的未来,  交付顺序
                    统一视野(vision), 范围(scope)，时间期限(time line)
                pre-view(release)
                    release中的产品功能, 和前几个迭代从backlog中要交付的工作项(item)
                now-view(iteration)
                    团队在一次迭代中要交付的需求(requirements)
            优先级，留空间适应变化
        项目事件
            完成产品总体计划必要的工作项, 详尽且切合目的
            分解目的，制定步骤
        路标
            关键工作项完成的时间节点(里程碑)
            结果反馈：审视是否偏离，试验中改进
            确定在每个时间范围内实现可衡量的结果。定义为目标关键结果(OKR)、关键性能指标(KPI)
    种类
        基于目标
            current
            near term
            future
        基于功能
            5000新用户
    步骤
        确定目标
        分解目标，穷尽事项，组织，优先级排序
        使用优化框架
            effort / impact
            impact / goal
            卡洛斯模型?
    注意
        定义战略主题(名词)，抓住核心用户行为的本质、产品能力、竞争优势、技术改进
        保持路线图战略，避免战术
        每个计划阶段都考虑优先级, 每个目标、动作、发布、特性的价值可见性
        始终在试验(ABE), 为了正确定义目标和后续特征
            先做出有根据的猜测
            测试
            基于反馈迭代

# 业务
    目标
        降低人才素质需求
        减少开发时间
    分类
        创造虚拟空间
        自动化
        辅助决策
    思路
        逻辑: 因果(演绎), 时间, 空间, 优先
        方法: 5w2h(who, when, where, why, what, how, how much)
        建模:
            中心                                # 调整抽象领域和层次(视问题决定)
                自上而下                        # 问题明确，展开
                自下而上                        # 内容分类、剪枝、归纳
            分解
                MECE(mutually exclusive collectively exhaustive)
                    正交
                    穷尽
        经验
            优秀的产品都有全局把控感(confluence, jira)
            设计思想多源自: 操作系统、编译器、函数式
            深入一线(面对客户)
            思考全面, 全局
            考虑需求本质，考虑上下游全局
            想清楚再行动
    过程
        发掘(discovery)
            价值定位(价值驱动)
            客户体验梳理和设计
            愿景
            干系人
            电梯演讲收敛
        定义(define)
            用户旅程，业务流程
            事件风暴 -> 映射技术 -> 架构
        设计(design)
            总体
                识别问题域, 归纳服务, 上下游关系
                架构图, api, 技术栈
                提升方向, 改进
            迭代
                价值/成本分布图
                milestone演进
                业务技术/需求拆解全景图(白板贴标)
                mvp(minimum viable product最小可行计划)迭代计划
        开发(develop)
            度量, 质量指标
            工具选择, 规范
            架构守护，治理
        实施策略
        交付
        产品生命周期管理
            目标, 资本
            机会点->需求
    角度决定设计
        找到不动点
        如对cache的设计
            业务角度
                选择简单易用的缓存框架
                有人会用，学习成本别太高
                关注数据模型结构设计
                缓存更新真麻烦
            paas角度
                声明式使用，配置文件设置
                缓存对比，选择强大且稳定的
                存取接口设计，方便易用
                数据变动监听，自动刷新缓存
            平台角度
                缓存服务器集群方式
                存储空间监控
                命中率监控
                避免缓存集中失效引起雪崩
    不过度设计      # 不超出需求，不用复杂方式实现
                    # 少就是多，应一减再减。简单才能强大，也会提高性能和扩展性
        范围减少    # 28原则，最小可行产品
        设计减少    # 易理解，低成本，可扩展
        实施减少    # 找开源->找内部已实现->找方案描述->自己解决
        二八定律
    墨菲定律
        事情不是表面看起来那么简单
        事情都会比预计时间长
        可能出错总会出错
        如果你担心发生，它更可能发生
    维护
        设计时考虑扩展性
            DID(design, implement, deploy)(设计20倍, 实现3-20倍, 部署1.5-3倍)
        设计能够监控的应用
        版本升降      # 代码仓库
    业务
        防重          # 重复提交，重复扣减，重复支付(异构系统无法防重，用退款处理)
            防重key, 防重表
        幂等          # 消息处理，第三方支付回调
        流程要抽象     # 如工作流
        状态与状态机
            订单系统
                # 状态多时用状态机驱动
                正向状态(待付款、待发货、已发货、完成)
                逆向状态(取消、退款)
                状态轨迹    # 跟踪和记日志，可回溯
                并发修改，状态变更有序，状态变更消息有序
    前端
        减少dns查找     # dns可能查多个域
        减少对象        # 页面布局少，图片合并。对象不要过大，减少到浏览器并发连接数
        后台系统操作可反馈   # 便于确认效果
    文档和注释
        设计架构
        设计思想
        数据字典/业务流程
        现有问题
# 设计
    分层做维度扩展
## DDD
## DODAF2.0
    介绍
        美国国防部（DOD）
        项目立项和顶层架构间，建立跟踪机制
    八种视图
        全视图
        数据与信息视图
        标准视图
        能力视图
        作战视图
        服务视图
        系统视图
        项目视图
    业务组件化
        基本的、唯一的、不重复的，可单独运行
# 项目
## 分层
    mv*
        mvc
            # view controller model, 单向循环
        mvp
            # view presenter model, presenter双向交互
        mvvm
            # view view-model model, view-model双向绑定

    验证
    异常层
        # 封装每层异常为不同异常类
    过滤层
    监听器
    日志
    测试
## 稳定
    高并发、高可用、高可靠
    容量规划(流量、容量)
    SLA(service level agreement)制定(吞吐量、响应时间、可用性、降级方案)
    压测方案(线下、线上)
    监控报警(机器负载、响应时间、可用率)
        tracing
    应急预案(容灾、降级、限流、隔离、切流量、可回滚)
### 高并发原则
    无状态     # 应用无状态，配置有状态
        尽可能浏览器端维护会话
        分布式缓存放状态
    拆分  # 加法组合，乘法功能
          # 项目死于1到10，或10到100，因为解耦不够，无法重构
        业务拆分
        功能细分
        读写      # 读缓存，写分库分表，聚合数据
        AOP      # 如CDN
        模块      # 代码特征，如基础模块分库分表，数据库连接池
    扩展
        服务化发展
            进程内服务
            单机远程服务
            集群手动注册服务(nginx负载多实例)
            自动注册和发现服务(zookeeper)
            服务分组/隔离/路由
            服务治理(限流/黑白名单)
        AKF扩展立方
            x轴 横向复制                 # 复制服务或db, 瓶颈：内存缓存、特有数据
            y轴 面向功能、服务、资源拆分   # 微服务
                动词拆分                 # 登录、搜索、推荐等
                名词拆分                 # 目录、库存、账户等
            z轴 拆相近东西               # 数据分片(大小客户、地区、新旧等)
        横向扩展    # 复制服务或数据分散负载，纵向扩展是升级设备
            使用经济型系统
            扩展数据中心      # 三实时站点备份: a(0.5b, 0.5c), b(0.5a, 0.5c), c(0.5a,0.5b), 尽量分散
            使用云
    通信      # 要异步
        消息队列
            作用
                服务解耦
                异步处理
                流量削峰/缓冲     # 如促销期
            问题
                丢失/失败     # 持久化，日志，报警, 数据校对修正(worker扫库)
                重复          # 业务上防重
            例子
                redis扣库存->记录日志->同步worker->DB
        消息总线可扩展     # x扩展不行，y扩展用专用总线(降低了灵活性), z扩展根据客户
        减少拥挤          # 消息划分价值
    数据异构
        例子
            聚合数据表(一般KV存储)   # 数据闭环(不依赖其它服务)
            历史归档
    缓存
        客户端
            浏览器缓存   # Pragma, Expires, Cache-control
            ajax
            app缓存     # 大促时更新静态资源, 地图
        客户端网络      # 代理服务器缓存
        广域网
            代理服务器(如CDN)
                推送 或 拉取(回源)
            镜像服务器
            P2P
        源站
            接入层缓存   # 如页面缓存，用redis
                url重写
                一致性哈希
                proxy_cache         # 内存/SSD缓存内容
                proxy_cache_lock    # 一段时间的回源合并成一个
                shared_dict         # lua, 重启缓存不丢失
            应用层缓存           # 如搜索，建议物品等
                堆内缓存
                堆外缓存        # local redis cache
            分布式缓存(接入层后)
                redis集群     # 异步化写入, lua-resty-lock(非阻塞锁)
            对象缓存    # db和应用间的查询结果集
            静态化, 伪静态化
            服务器操作系统缓存
        并发化
    选择工具
        数据库     # rdb, nosql, hadoop
        防火墙     # 墙需要的东西
        日志       # 采集分析
        用同品牌设备
        慎用第三方
    容错
        隔离               # 不同步调用，限制异步调用(数量和超时)，能迅速发现故障
        不单点             # 一切都出故障
        不系统串联
        功能支持启用禁用    # 实现wire on/wire off框架
### 高可用原则
    降级
        开关集中化管理, 推送开关配置
        开关前置      # nginx层做开关
        可降级读服务   # 只读本地缓存、只读分布式缓存、只读默认数据
        业务降级      # 部分业务异步，处理高优先级，分配流量保障系统可用
    限流
        思路
            恶意请求流量只访问cache
            穿透到应用的流量用nginx limit
            恶意ip nginx deny
        切流量     # 某服务器挂了
            DNS切换
            httpDNS         # app配置，绕过运营商localDNS
            lvs/haproxy     # 切换故障的nginx
            nginx           # 切换故障应用
    可回滚
        事务
        代码库
        部署版本
        数据版本
        静态资源版本
## 微服务
    单体应用问题
        复杂: 模块多, 边界模糊, 依赖关系不清晰, 代码质量不统一
        技术债务: 不坏不修
        部署频率低: 迭代要部署整个应用，部署时间长，风险高。修复问题慢, 易出错
        可靠性差: 某bug导致整个应用崩溃
        扩展性差
        阻碍技术更新
    特征
        服务组件化
        按业务组织团队
        负责的态度, 不再是交付给维护者
        粗粒度通信, http(二进制协议)或消息总线
        去中心化治理
        去中心化管理数据
        基础设施自动化
        容错设计
        演进式设计
    原则
        单一职责
        自洽
        轻量级通信
        服务粒度: 边界(DDD中的界限上下文)
    持续发布
        工具链，自动化
        契约
        架构守护
        灰度替换
    *aaS
        SaaS(software as a service)
        PaaS(platform as a service)
        aPaaS(application PaaS)         # 简单配置产生任意需求的application
        saPaaS(specific aPaaS)          # 领域定制的aPaaS
        GaPaaS(generator of aPaaS)      # 脚手架，产生定制的aPaaS
## Serverless
    只写业务代码，不关心服务器运行状态
    BaaS
        # Backend as a Service
    FaaS
        # Functions as a Service
## 云原生
    介绍
        cloud navtive, Pivotal 2013年提出
    12-Factor
        1 基准代码(code base)
            一份代码，多份部署
        2 依赖(dependences)
            显式声明依赖
        3 配置(config)
            配置存储于环境变量中
            环境变量粒度足够小，相对独立
        4 后端服务(backing services)
            后端服务作为附加资源, 与第三方服务不区别对待
        5 分离构建、发布、运行(build, release, run)
            构建: 代码转化到可执行包
            发布: 可执行包结合配置
            运行: 选定发布版本，按计划启动
        6 进程(process)
            多个无状态进程运行
        7 端口(port binding)
            网络服务通过端口绑定提供服务
            完全自我加载不依赖网络服务器
        8 并发(concurrency)
            进程作为一等公民
            通过进程模型扩展并发
        9 易处理(disposability)
            进程快速启动、优雅终止可最大化健壮性
            追求最小启动时间, 收到SIGTERM优雅终止，突然死亡时保持健壮
        10 环境等价(dev/prod parity)
            开发环境等价线上环境
        11 日志(logs)
            日志作为事件流
            应用本身使用stdout事件流，不考虑存储输出流，不管理日志
        12 管理进程(admin processes)
            管理进程不常驻, 一次性运行
            使用同样环境、代码版本、配置、依赖隔离, 避免同步问题
            提供REPL shell使一次性脚本变简单
### Service Mesh
    处于 TCP/IP 之上的抽象层
# 服务化
    # autonomy.design
    表现
        一个需求拉很多人，代码写进来就删不掉了
        通用功能要么多种实现，要么参数过多
        线上问题难定位，本地做不了有意义的测试，反馈周期特别长
    本质
        减少沟通
            autonomy(自治): 减少沟通，功能可以删掉
                问题: 产品从整体效果出发，开发从实现出发
                依赖倒置
                    UI插槽, 服务集成
                    实现(服务)
                        编译时: 模板、函数替换
                        运行时: 组合对象、组合函数
                    实现(UI)
                        编译时: 页面模板替换, 显式组合与隐式组合
                        运行时: Vue插槽
            feedback(反馈): 故障定位，测试反馈，发版反馈，用户反馈无响应
                控制边界
                    进程
                        跨进程调用监控: 基础设施完善
                        OS强制配额、安全性: 基础设施好
                        内存隔离
                    函数
                        caller/callee索引: 同步调用栈、异步调用链、组件树
                        问题: 日志多，负责模糊
                    插件
                控制变更
                    多进程
                        多进程部署
                    多租户
                    多变种
                        配置中心下发开关
            consistency(一致性): 工具复用
                用户可见的一致性: UI/UE设计，前端落地
                autonomy: 上层业务推动
                    问题: 依赖修改要慎重
                feedback: QA, KPI
    拆分
        组合关系
            加法
            乘法
            一致性复用