---
Categories : ["设计"]
title: "设计-工程"
date: 2018-10-10T17:39:31+08:00
---
# 思想
    设计
        墨菲定律
            事情不是表面看起来那么简单
            事情都会比预计时间长
            可能出错总会出错
            如果你担心发生，它更可能发生
        二八定律
    系统划分与组织划分
        康威定律
            系统架构是公司组织架构的反映
            按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本
            沟通出现问题，考虑调整组织架构
            在该拆分时拆分
    角度决定设计
        如对cache的设计
            业务角度
                选择简单易用的缓存框架
                有人会用，学习成本别太高
                关注数据模型结构设计
                缓存更新真麻烦
            paas角度
                声明式使用，配置文件设置
                缓存对比，选择强大且稳定的
                存取接口设计，方便易用
                数据变动监听，自动刷新缓存
            平台角度
                缓存服务器集群方式
                存储空间监控
                命中率监控
                避免缓存集中失效引起雪崩
    为了简单
        开发和运维分离
        业务和基础架构分离
        无状态和有状态分离
        业务间乘法(正交)而非加法              # 升维的特点, 正交叠加
        多层抽象, 不断隐去底层(约定大于配置)    # 升维的特点, 抽象观察
    考虑因素
        高并发、高可用、高可靠
        容量规划(流量、容量)
        SLA(service level agreement)制定(吞吐量、响应时间、可用性、降级方案)
        压测方案(线下、线上)
        监控报警(机器负载、响应时间、可用率)
            tracing
        应急预案(容灾、降级、限流、隔离、切流量、可回滚)
    微服务
        单体应用问题
            复杂: 模块多, 边界模糊, 依赖关系不清晰, 代码质量不统一
            技术债务: 不坏不修
            部署频率低: 迭代要部署整个应用，部署时间长，风险高。修复问题慢, 易出错
            可靠性差: 某bug导致整个应用崩溃
            扩展性差
            阻碍技术更新
        特征
            服务组件化
            按业务组织团队
            负责的态度, 不再是交付给维护者
            粗粒度通信, http(二进制协议)或消息总线
            去中心化治理
            去中心化管理数据
            基础设施自动化
            容错设计
            演进式设计
        原则
            单一职责
            自洽
            轻量级通信
            服务粒度: 边界(DDD中的界限上下文)
        *aaS
            SaaS(software as a service)
            PaaS(platform as a service)
            aPaaS(application PaaS)         # 简单配置产生任意需求的application
            saPaaS(specific aPaaS)          # 领域定制的aPaaS
            GaPaaS(generator of aPaaS)      # 脚手架，产生定制的aPaaS
# 架构模型
    数据处理
        lambda架构                           # 实时大数据, stream使用
            批处理层
            实时处理层
            服务层
        sharing-nothing                     # cpu之间不共享内存和磁盘
    DDD(domain driven design)
        本质
            维护概念完整性，避免腐化
        entity
            主存储(可变)
            互相派生                         # 如命令和事件派生状态, 事件派生状态等
                状态(可变)
                命令(command, 不可变)
                事件(event, 不可变)
        entity representation               # 数据表现
            多representation一致性
            representation表达业务的难易

            entity物理介质/表现形式            # 表现形式一致性(同步), 多份存储, 数据派生合并转化
                OLTP(mysql)                 # 点查询
                OLAP(clickHouse)            # 范围查询
                queue(kafka)                # 顺序读, 低延迟
                业务服务                     # 业务逻辑, 像虚拟的表
        entity再派生
            viewModel(不可变)
            子集(不可变)
            视图(不可变)
        BC(bounded context)                 # entity分组
            分解复杂度: 系统、组织部门
            内部一致性: 数据、概念

            集成
                边界entity                   # 授权、binlog、视图数据。本质是权限
                    东西、单据
                    event
                    可实现成worker托管

                    物理介质
                        queue
                        只读db
                        rpc虚拟表
            粒度
                BC尽可能少而大
            关系
                时间错开
                    外键关系                 # BC挂载到BC, 如后台系统与计费系统的定价, 运营人员与服务系统的配置, 流程节点系统对流程的依赖
                        rpc
                        数据库
                        数据复制
                    报表关系
                        时效性高
                        一般数据复制          # 所以边界entity是数据变更event
                    触发关系                 # fire and forget
                    交棒关系
                        下游给上游command/event, 上游触发
                        上游实现降级          # 下游不可用时，安慰语
                时间同时
                    accountable/responsible关系                 # 像项目的负责人与开发人
                        最小化accountable
                            补偿
                            responsible提供自己界面
                        边界entity是rpc虚拟表, 插入command, 返回event
                    抢资源关系
                        锁服务
        应用开发      
            处理entity表现
# 云原生应用
    十二要素
        一份代码，多份部署
        显式声明依赖
        外部保存配置
        服务作为调用资源
        分离构建、发布、运行
            构建: 代码转化到可执行包
            发布: 可执行包结合配置
            运行: 选定发布版本，按计划启动
        多个无状态进程运行
        端口绑定服务
        进程作为一等公民并发扩展
        进程易处理: 快速启动、优雅终止
        开发环境等价线上环境
        日志作为事件流
        管理进程不常驻, 一次性运行
# 高并发原则
    无状态     # 应用无状态，配置有状态
        尽可能浏览器端维护会话
        分布式缓存放状态
    拆分  # 加法组合，乘法功能
          # 项目死于1到10，或10到100，因为解耦不够，无法重构
        业务拆分
        功能细分
        读写      # 读缓存，写分库分表，聚合数据
        AOP      # 如CDN
        模块      # 代码特征，如基础模块分库分表，数据库连接池
    扩展
        服务化发展
            进程内服务
            单机远程服务
            集群手动注册服务(nginx负载多实例)
            自动注册和发现服务(zookeeper)
            服务分组/隔离/路由
            服务治理(限流/黑白名单)
        AKF扩展立方
            x轴 横向复制                 # 复制服务或db, 瓶颈：内存缓存、特有数据
            y轴 面向功能、服务、资源拆分   # 微服务
                动词拆分                 # 登录、搜索、推荐等
                名词拆分                 # 目录、库存、账户等
            z轴 拆相近东西               # 数据分片(大小客户、地区、新旧等)
        横向扩展    # 复制服务或数据分散负载，纵向扩展是升级设备
            使用经济型系统
            扩展数据中心      # 三实时站点备份: a(0.5b, 0.5c), b(0.5a, 0.5c), c(0.5a,0.5b), 尽量分散
            使用云
    通信      # 要异步
        消息队列
            作用
                服务解耦
                异步处理
                流量削峰/缓冲     # 如促销期
            问题
                丢失/失败     # 持久化，日志，报警, 数据校对修正(worker扫库)
                重复          # 业务上防重
            例子
                redis扣库存->记录日志->同步worker->DB
        消息总线可扩展     # x扩展不行，y扩展用专用总线(降低了灵活性), z扩展根据客户
        减少拥挤          # 消息划分价值
    数据异构
        例子
            聚合数据表(一般KV存储)   # 数据闭环(不依赖其它服务)
            历史归档
    缓存
        客户端
            浏览器缓存   # Pragma, Expires, Cache-control
            ajax
            app缓存     # 大促时更新静态资源, 地图
        客户端网络      # 代理服务器缓存
        广域网
            代理服务器(如CDN)
                推送 或 拉取(回源)
            镜像服务器
            P2P
        源站
            接入层缓存   # 如页面缓存，用redis
                url重写
                一致性哈希
                proxy_cache         # 内存/SSD缓存内容
                proxy_cache_lock    # 一段时间的回源合并成一个
                shared_dict         # lua, 重启缓存不丢失
            应用层缓存           # 如搜索，建议物品等
                堆内缓存
                堆外缓存        # local redis cache
            分布式缓存(接入层后)
                redis集群     # 异步化写入, lua-resty-lock(非阻塞锁)
            对象缓存    # db和应用间的查询结果集
            静态化, 伪静态化
            服务器操作系统缓存
        并发化
    选择工具
        数据库     # rdb, nosql, hadoop
        防火墙     # 墙需要的东西
        日志       # 采集分析
        用同品牌设备
        慎用第三方
    容错
        隔离               # 不同步调用，限制异步调用(数量和超时)，能迅速发现故障
        不单点             # 一切都出故障
        不系统串联
        功能支持启用禁用    # 实现wire on/wire off框架
# 高可用原则
    降级
        开关集中化管理, 推送开关配置
        开关前置      # nginx层做开关
        可降级读服务   # 只读本地缓存、只读分布式缓存、只读默认数据
        业务降级      # 部分业务异步，处理高优先级，分配流量保障系统可用
    限流
        思路
            恶意请求流量只访问cache
            穿透到应用的流量用nginx limit
            恶意ip nginx deny
        切流量     # 某服务器挂了
            DNS切换
            httpDNS         # app配置，绕过运营商localDNS
            lvs/haproxy     # 切换故障的nginx
            nginx           # 切换故障应用
    可回滚
        事务
        代码库
        部署版本
        数据版本
        静态资源版本
# 业务设计
    不过度设计    # 不超出需求，不用复杂方式实现
                 # 少就是多，应一减再减。简单才能强大，也会提高性能和扩展性
        范围减少    # 28原则，最小可行产品
        设计减少    # 易理解，低成本，可扩展
        实施减少    # 找开源->找内部已实现->找方案描述->自己解决
    维护
        设计时考虑扩展性
            DID(design, implement, deploy)(设计20倍, 实现3-20倍, 部署1.5-3倍)
        设计能够监控的应用
        版本升降      # 代码仓库
    业务
        防重          # 重复提交，重复扣减，重复支付(异构系统无法防重，用退款处理)
            防重key, 防重表
        幂等          # 消息处理，第三方支付回调
        流程要抽象     # 如工作流
        状态与状态机
            订单系统
                # 状态多时用状态机驱动
                正向状态(待付款、待发货、已发货、完成)
                逆向状态(取消、退款)
                状态轨迹    # 跟踪和记日志，可回溯
                并发修改，状态变更有序，状态变更消息有序
    前端
        减少dns查找     # dns可能查多个域
        减少对象        # 页面布局少，图片合并。对象不要过大，减少到浏览器并发连接数
        后台系统操作可反馈   # 便于确认效果
    文档和注释
        设计架构
        设计思想
        数据字典/业务流程
        现有问题
# 开发模型
    TDD(test-driven development)
        先单元测试
    BDD(behavior-driven development)
        TDD的变种, 重点描述行为
# 分层
    mv*
        mvc
            # view controller model, 单向循环
        mvp
            # view presenter model, presenter双向交互
        mvvm
            # view view-model model, view-model双向绑定

    验证
    异常层
        # 封装每层异常为不同异常类
    过滤层
    监听器
    日志
    测试